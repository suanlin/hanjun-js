<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>

    <button>按钮一</button>
    <button>按钮二</button>
    <button>按钮三</button>



    <script>
        /*
        函数就是一个闭包,函数可以使用函数之外定义的变量.
    
        内部函数的作用域链仍然保持着对父函数活动对象的引用,就是闭包(closure)
    
        闭包必须满足:(1)函数嵌套函数 (2)子函数引用父函数的参数或变量 (3)并且子函数还被外界所引用.
        这个时候子函数的作用域链任然保持对父函数活动对象的引用,父函数的参数和变量不会被浏览器垃圾回收机制给回收,此时打印父函数的函数返回值,会发现在返回值下面有一个scopes,这个scopes下面有一个closure,它就是闭包(整个父级都形成了闭包环境)
        
        全局的活动对象在关闭浏览器之后才会被销毁
        
        */

        // function fn() {
        //     var a = 10;
        //     function fn2() {
        //         a++;
        //         console.log(a);
        //     }
        //     function fn3(){
        //     }
        //     console.dir(fn3) //fn3(){}
        //     return fn2;
        // }
        // var f = fn(); 
        // console.dir(f); //fn2() {}
        // f(); // 11
        // f(); //12    达到闭包的条件所以 a = 11 不会被删除 所以会再次被加1





        // function fn1(a) {
        //     function fn() {
        //         a++;
        //         console.log(a); 
        //     }
        //     return fn;
        // }
        // fn1(1)(); // 2
        // fn1(1)(); //2

        // var f = fn1(1);
        // f(); //2
        // f(); //3

        // console.dir(f); //fn()




        const btns = document.querySelectorAll('button');
        for (var i = 0; i < btns.length; i++) {
            function fn(a) {      
                btns[a].onclick = function () { //使用闭包解决异步的问题
                    alert(a);
                }
            }
            fn(i)
        }




    </script>
</body>

</html>