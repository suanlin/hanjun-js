<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
<script>
/*
    this
        window
            单纯的函数调用 fn()
        事件对象
            事件函数中的this,事件触发的对象
        主
            this就是.前面的应用类型
        箭头函数
            跟着创建箭头函数时的上下文作用域
    
    单例模式,高级单例模式,实例身上集合了各种属性和方法
    (function (){
        return {}
    })()

    工厂模式(为了批量生成对象,其中有初始化,加工,出厂)

    面向对象
        把具有相同特征的代码抽离出来归为一类
        再把描述这个类的相同的内容挂在这个类的原型下的一种编程思想

    原型与原型链的关系
        什么是原型
            函数下的一个属性prototype,值为对象
            作用
                构造函数原型下的属性或者方法只给这个构造函数的实例使用
        
        什么是原型链
            __proto__每一个实例上都有一个__proto__属性
            作用
                实例上的原型链 === 构造函数的原型





    实例下如果有属性或方法,优先实例下的属性或方法,如果没有就
    通过实例的原型链找到了构造函数的原型
    构造函数原型的原型链找到了Object
    Function的原型链等于Function的原型

*/



// document.onclick = function(){
//     console.log(this) //document 点击事件中的this是触发事件的内容
//     let f = () => { 
//         console.log(this)  //document 箭头函数中的this为上一层的作用域
//     }
//     f()
// }



// function fn(){
//     console.log(this) //fn函数 点前面的是谁就是谁
// }
// let obj = {
//     fn:{
//         func:{
//             fn:fn
//         }
//     }
// }
// obj.fn.func.fn() //调用




function Fn(){
    this.a = 10
}
Fn.prototype.a = 20
Fn.a = 30
Fn.prototype.a=40
Object.prototype.a = 60
Function.prototype.a = 50
Function.a = 70
let f = new Fn()
f.a = 40
// console.log(Fn.__proto__.prototype.__proto__.a)//Function.prototype.prototype.__proto__.a  没有第二个prototype所以它会为undefined,undefind下没有proto所以会报错
// console.log(f.__proto__.__proto__.a) //Fn.prototype.__proto__.a  ->Object.prototype.a  60
// console.log(f.__proto__.prototype.a) //Fn.prototype.prototype.a 没有所以报错
// console.log(Object.a) // Function.prototype.a  50
// console.log(Fn.__proto__.__proto__.a) //Function.protptype.__proto__.a 60
// console.log(f.a) //40
// console.dir(Function) //70
// console.log(Fn.__proto__ === Fn.prototype); //false



</script>
</body>
</html>